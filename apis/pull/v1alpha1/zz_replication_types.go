// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ReplicationInitParameters struct {

	// When true, enables distributed checksum storage. For more information, see [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
	CheckBinaryExistenceInFilestore *bool `json:"checkBinaryExistenceInFilestore,omitempty" tf:"check_binary_existence_in_filestore,omitempty"`

	// The Cron expression that determines when the next replication will be triggered.
	CronExp *string `json:"cronExp,omitempty" tf:"cron_exp,omitempty"`

	// When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. add, deleted or property change. Default value is `false`.
	EnableEventReplication *bool `json:"enableEventReplication,omitempty" tf:"enable_event_replication,omitempty"`

	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Password for local repository replication. Required for local repository, but not needed for remote repository.
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	PathPrefix *string `json:"pathPrefix,omitempty" tf:"path_prefix,omitempty"`

	// Proxy key from Artifactory Proxies setting
	Proxy *string `json:"proxy,omitempty" tf:"proxy,omitempty"`

	// Repository name.
	RepoKey *string `json:"repoKey,omitempty" tf:"repo_key,omitempty"`

	SocketTimeoutMillis *float64 `json:"socketTimeoutMillis,omitempty" tf:"socket_timeout_millis,omitempty"`

	SyncDeletes *bool `json:"syncDeletes,omitempty" tf:"sync_deletes,omitempty"`

	SyncProperties *bool `json:"syncProperties,omitempty" tf:"sync_properties,omitempty"`

	SyncStatistics *bool `json:"syncStatistics,omitempty" tf:"sync_statistics,omitempty"`

	// URL for local repository replication. Required for local repository, but not needed for remote repository.
	URL *string `json:"url,omitempty" tf:"url,omitempty"`

	// Username for local repository replication. Required for local repository, but not needed for remote repository.
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type ReplicationObservation struct {

	// When true, enables distributed checksum storage. For more information, see [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
	CheckBinaryExistenceInFilestore *bool `json:"checkBinaryExistenceInFilestore,omitempty" tf:"check_binary_existence_in_filestore,omitempty"`

	// The Cron expression that determines when the next replication will be triggered.
	CronExp *string `json:"cronExp,omitempty" tf:"cron_exp,omitempty"`

	// When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. add, deleted or property change. Default value is `false`.
	EnableEventReplication *bool `json:"enableEventReplication,omitempty" tf:"enable_event_replication,omitempty"`

	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	PathPrefix *string `json:"pathPrefix,omitempty" tf:"path_prefix,omitempty"`

	// Proxy key from Artifactory Proxies setting
	Proxy *string `json:"proxy,omitempty" tf:"proxy,omitempty"`

	// Repository name.
	RepoKey *string `json:"repoKey,omitempty" tf:"repo_key,omitempty"`

	SocketTimeoutMillis *float64 `json:"socketTimeoutMillis,omitempty" tf:"socket_timeout_millis,omitempty"`

	SyncDeletes *bool `json:"syncDeletes,omitempty" tf:"sync_deletes,omitempty"`

	SyncProperties *bool `json:"syncProperties,omitempty" tf:"sync_properties,omitempty"`

	SyncStatistics *bool `json:"syncStatistics,omitempty" tf:"sync_statistics,omitempty"`

	// URL for local repository replication. Required for local repository, but not needed for remote repository.
	URL *string `json:"url,omitempty" tf:"url,omitempty"`

	// Username for local repository replication. Required for local repository, but not needed for remote repository.
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type ReplicationParameters struct {

	// When true, enables distributed checksum storage. For more information, see [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
	// +kubebuilder:validation:Optional
	CheckBinaryExistenceInFilestore *bool `json:"checkBinaryExistenceInFilestore,omitempty" tf:"check_binary_existence_in_filestore,omitempty"`

	// The Cron expression that determines when the next replication will be triggered.
	// +kubebuilder:validation:Optional
	CronExp *string `json:"cronExp,omitempty" tf:"cron_exp,omitempty"`

	// When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. add, deleted or property change. Default value is `false`.
	// +kubebuilder:validation:Optional
	EnableEventReplication *bool `json:"enableEventReplication,omitempty" tf:"enable_event_replication,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Password for local repository replication. Required for local repository, but not needed for remote repository.
	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	PathPrefix *string `json:"pathPrefix,omitempty" tf:"path_prefix,omitempty"`

	// Proxy key from Artifactory Proxies setting
	// +kubebuilder:validation:Optional
	Proxy *string `json:"proxy,omitempty" tf:"proxy,omitempty"`

	// Repository name.
	// +kubebuilder:validation:Optional
	RepoKey *string `json:"repoKey,omitempty" tf:"repo_key,omitempty"`

	// +kubebuilder:validation:Optional
	SocketTimeoutMillis *float64 `json:"socketTimeoutMillis,omitempty" tf:"socket_timeout_millis,omitempty"`

	// +kubebuilder:validation:Optional
	SyncDeletes *bool `json:"syncDeletes,omitempty" tf:"sync_deletes,omitempty"`

	// +kubebuilder:validation:Optional
	SyncProperties *bool `json:"syncProperties,omitempty" tf:"sync_properties,omitempty"`

	// +kubebuilder:validation:Optional
	SyncStatistics *bool `json:"syncStatistics,omitempty" tf:"sync_statistics,omitempty"`

	// URL for local repository replication. Required for local repository, but not needed for remote repository.
	// +kubebuilder:validation:Optional
	URL *string `json:"url,omitempty" tf:"url,omitempty"`

	// Username for local repository replication. Required for local repository, but not needed for remote repository.
	// +kubebuilder:validation:Optional
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

// ReplicationSpec defines the desired state of Replication
type ReplicationSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ReplicationParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ReplicationInitParameters `json:"initProvider,omitempty"`
}

// ReplicationStatus defines the observed state of Replication.
type ReplicationStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ReplicationObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Replication is the Schema for the Replications API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,artifactory}
type Replication struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.repoKey) || (has(self.initProvider) && has(self.initProvider.repoKey))",message="spec.forProvider.repoKey is a required parameter"
	Spec   ReplicationSpec   `json:"spec"`
	Status ReplicationStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ReplicationList contains a list of Replications
type ReplicationList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Replication `json:"items"`
}

// Repository type metadata.
var (
	Replication_Kind             = "Replication"
	Replication_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Replication_Kind}.String()
	Replication_KindAPIVersion   = Replication_Kind + "." + CRDGroupVersion.String()
	Replication_GroupVersionKind = CRDGroupVersion.WithKind(Replication_Kind)
)

func init() {
	SchemeBuilder.Register(&Replication{}, &ReplicationList{})
}
